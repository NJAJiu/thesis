% peer_poll.tex
\chapter{Peer/Poll Processes}
\label{cha:peer/poll}

\section{Concepts}%
\label{sec:peer/poll_concepts}
\begin{enumerate}
    \item Offset $\theta$\\
        The maximum-likelihood time offset of the server clock relative to the
        system clock. This concept describes how different the client's time
        and the server's time are.
        % $$\theta_{AB} = \frac{1}{2}\left[\left(T_{i-2} - T_{i-3}\right) +
        % \left(T_{i-1} - T_i\right)\right]$$
    \item Delay $\delta$\\
        The round-trip delay between the client and server. It is equal to the
        time that a massage travels from the client to the server and the time
        it comes back.
        % $$\delta_{AB} = \left(T_{i} - T_{i-3}\right) - \left(T_{i-1} -
        % T_{i-2}\right)$$
    \item Dispersion $\varepsilon$\\
        The maximum error inherent in the measurement.
        Another definition: Potential clock offset error due to the maximum
        uncorrected system clock frequency error.
        These definitions are in some respect confused, we will discuss it with
        more detail in Section~\ref{sec:peer_processes}.
        % from website https://www.eecis.udel.edu/~mills/ntp/html/stats.html
\end{enumerate}

\section{Overview}%
\label{sec:overview}
Figure~\ref{fig:peer_poll_processes} shows the basic architecture of peer/poll
processes. The communication between client and server uses on-wire protocol,
which can provide sample statistics ($\theta_0, \delta_0, t_0$ in the figure).
The recent eight samples are stored in a shift register, with one more sample
statistic added ($\varepsilon$).  Then peer process applies clock filter
algorithm, which generates peer statistics ($\theta, \delta, \varepsilon$ in
the figure), and passes them to system process.

\input{figures/peer_poll_figure.tex}
% fig:peer_poll_processes

The purpose of peer processes is to communicate with servers and to keep
statistics of the communications which can be used to determine how reliable
the servers are. And for poll processes, their job is to manage the
communications to get sufficient data without making the servers too busy.

\section{On wire protocol}%
\label{sec:on_wire_protocol}
In NTP subnet, a client can send request to server and the server sends back
response after it got the request. The whole round of the communication can
generate a sample. For every sample, the client wants to know the difference
between the server's system clock and its, aka offset.
But it may take a while for the server to give the response. And it is not
predictable, as well as the network delay between the two devices.
In NTP subnet, clients and servers communicate under on-wire protocol. It
provides a smart way to calculate offset and delay for every sample. 

\subsection{Statistics calculation}%
\label{sub:statistics_calculation}
Figure~\ref{fig:on_wire1} represents the timestamps and communications between
a client and a server. The vertical dash line indicates the same time. The
arrow indicates the communication packets sent from one side and received at
the other side. The notation $T_i$ stands for the timestamp gotten from the
system clock of one device. 

\input{figures/on_wire1.tex}
% fig:on_wire1

In ideal situation, if we have $T_1$ and $T_0$, which are timestamps gotten
from both devices at the same time, then we can get the offset $\theta$:
$$\theta = T_1 - T_0$$
But we cannot do this since we cannot determine whether two timestamps were
token at the same time. The on-wire protocol actually calculates the offset in
an alternative way:
\begin{equation}
    \theta = \frac{1}{2}\left[(T_3 - T_2) + (T_4 - T_5)\right]
    \label{eq:offset_def}
\end{equation}
Note that this equation is equivalent to:
$$\theta = \frac{T_3 + T_4}{2} - \frac{T_2 + T_5}{2}$$
which means that the offset is equal to the difference between two timestamps
which are the middle points of $T_3, T_4$ and $T_2, T_5$. 
If the network delay is symmetric, which means the time for
packets to travel from client to server and the time for packets to get back
are equal, the middle points are at the same time. In this case, it is
equivalent to the ideal situation. If the delay is asymmetric, there will be an
error of the calculation. This error is impossible to be corrected. However,
there is one scenario that the error can be attenuated.~\cite{redbook} We will
discuss this part in Section~\ref{sub:huff_n_puff_filter}.

The delay $\delta$ is calculated by:
\begin{equation}
    \delta = (T_5 - T_2) - (T_4 - T_3)
    \label{eq:delay_def}
\end{equation}
It is actually a difference of two time periods. It is not impacted by the
offset, since each time period is calculated using two timestamps from the same
device.
(NOTE: add the impact of frequency offset.)

There is another statistic $t$ in Figure~\ref{fig:peer_poll_processes}, which
indicates the time that the offset $\theta$ and delay $\delta$ are calculated.
In practice we can let $t = T_5$, because it is just used to indicate the order
of groups of sample statistics, we do not need it to be extremely accurate.
In Figure~\ref{fig:peer_poll_processes}, we add subscript 0 to distinguish the
new group of samples statistics and the groups which are in the shift register.

\subsection{Timestamps in NTP packet}%
\label{sub:timestamps_in_ntp_packet}
% how to store timestamps and modes
% https://www.eecis.udel.edu/~mills/onwire.html
NTP uses NTP packets in communications. The NTP packet is a UDP
datagram.~\cite{rfc5905} There are four timestamps in NTP packet header:
\begin{enumerate}
    \item Reference Timestamp\\
        Time when the system clock was last set or corrected.
    \item Origin Timestamp (\emph{org})\\
        Time at the client when the request packet departs from it.
    \item Receive Timestamp (\emph{rec})\\
        Time at the server when the request packet is receive by it.
    \item Transmit Timestamp (\emph{xmt})\\
        Time at the server when the response packet departs from it.
\end{enumerate}
In peer process, we are interested in another one: destination
timestamp(\emph{dst}), which is the time at the client when it receives the
response packet. And the reference timestamp is not interested here. In
Figure~\ref{fig:on_wire1}, the packet leave at $T_4$ contains $T_4, T_3$ and
$T_2$ in its header, where
$$ org = T_2,~rec = T_3,~xmt = T_4 $$
When the client gets the packet, it captures $dst = T_5$.

The purpose of on-wire protocol is to calculate offset $\theta$ and delay
$\delta$ based on the communication. The four timestamps used in
Equation~\ref{eq:offset_def} and Equation~\ref{eq:delay_def} are important,
which are \emph{org}, \emph{rec}, \emph{xmt} and \emph{dst}.
High accuracy requires that they are captured as close to the actual time of
the relative event (sending or receiving packet) as possible. On-wire protocol
provides two interleaved modes which are \emph{interleaved symmetric} and
\emph{interleaved broadcast}. They are extensions of basic symmetric mode and
basic broadcast mode.~\cite{on_wire} 
%
In basic modes, \emph{org} and \emph{xmt} in outgoing packet are captured
before the packet is made, which is not the timestamp when the packet is sent. 
This kind of timestamps are called \emph{softstamps}. In this case, 
after softstamp is captured, there are something else to do before sending the
packet, such as add validation information to the packet and adding the packet
to the output queue, then the packet will wait in the queue before it is sent.
For \emph{rec} and \emph{dst}, which are also called \emph{drivestamps}, they
are captured ``shortly after the input device interrupt and before adding the
buffer to the input queue''.\cite{on_wire} We can see that the drivestamps are
more accurate than softstamps because there is only a short delay by handling
the interrupt. If we can capture timestamps exactly when packets are sent or
received, they will be more accurate. However, we need additional hardware
support to do this.

In interleaved modes, we can make softstamps more accurate without
additional hardware support. The trade off is that we need more packets.
Instead of capturing softstamps before the packets are made, we can capture
them shortly after the output interrupt. In this case, the accuracy is similar
with drivestamps but they can not be sent in the very packets which they
represent the time they are sent. We need one more packet if we want to send
softstamps. More detail about interleaved modes are beyond the scope of this
thesis.

\subsection{Non-reliable protocol}%
\label{sub:non_reliable_protocol}
As mentioned in Section~\ref{sub:timestamps_in_ntp_packet}, the NTP packet is a
UDP datagram. This make on-wire protocol not reliable, which means that there
is no guarantee about the packet. Reliable delivery actually decreases the
reliability of NTP packet. Assume we are implementing on-wire protocol to make
it reliable by using similar technique like TCP, a lost packet will be sent
again. However, an identical packet is not valid since the timestamp which
indicates the time when the packet is sent is incorrect.

\section{Peer processes}%
\label{sec:peer_processes}
For each server, on-wire protocol provides sample statistics $\theta, \delta$
and $t$ and passes them to peer process. Then the clock filter algorithm
deals with them.

\subsection{Clock filter algorithm}%
\label{sub:clock_filter_algorithm}
The job of clock filter algorithm can be considered as two parts. First it
maintains sample statistics, second it calculates peer statistics.

\subsubsection{Sample statistics maintenance}%
\label{ssub:sample_statistics_maintenance}

\subsubsection{Peer statistics calculation}%
\label{ssub:peer_statistics_calculation}



\subsection{Huff-'n-puff filter}%
\label{sub:huff_n_puff_filter}

\section{Poll processes}%
\label{sec:poll_processes}


